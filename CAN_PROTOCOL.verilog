module baud_gen(input clk, input reset, output reg tick);
  reg [7:0] count;
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      count <= 0;
      tick <= 0;
    end else begin
      if (count == 9) begin
        count <= 0;
        tick <= 1;
      end else begin
        count <= count + 1;
        tick <= 0;
      end
    end
  end
endmodule

// ----------------------------
// Module: CAN Frame Generator
// ----------------------------
module can_frame_gen(input clk, input reset, input tick, output reg [63:0] frame, output reg done);
  reg [7:0] id = 8'b10101010;
  reg [3:0] dlc = 4'b0101;
  reg [31:0] data = 32'hA5A5A5A5;
  reg [6:0] crc = 7'b1100110; // Example hardcoded CRC
  reg [2:0] state;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      frame <= 0;
      done <= 0;
      state <= 0;
    end else if (tick) begin
      case (state)
        0: begin
          frame[63:56] <= id;
          state <= 1;
        end
        1: begin
          frame[55:52] <= dlc;
          state <= 2;
        end
        2: begin
          frame[51:20] <= data;
          state <= 3;
        end
        3: begin
          frame[19:13] <= crc;
          state <= 4;
        end
        4: begin
          frame[12:0] <= 13'b1111111111111; // EOF or padding
          done <= 1;
          state <= 5;
        end
      endcase
    end
  end
endmodule

// ----------------------------
// Module: CAN Frame Receiver
// ----------------------------
module can_frame_rx(input [63:0] frame, output [7:0] id, output [3:0] dlc, output [31:0] data, output [6:0] crc);
  assign id = frame[63:56];
  assign dlc = frame[55:52];
  assign data = frame[51:20];
  assign crc = frame[19:13];
endmodule

// ----------------------------
// Module: CRC Checker
// ----------------------------
module can_crc_checker(input [47:0] raw_data, input [6:0] received_crc, output reg crc_valid);
  reg [6:0] crc;
  integer i;
  parameter [6:0] poly = 7'b1001101;

  always @(*) begin
    crc = 7'b0;
    for (i = 47; i >= 0; i = i - 1) begin
      crc = {crc[5:0], raw_data[i]} ^ (crc[6] ? poly : 7'b0);
    end
    crc_valid = (crc == received_crc);
  end
endmodule

// ----------------------------
// Module: ACK Checker
// ----------------------------
module ack_checker(input crc_valid, output reg ack, output reg [7:0] status);
  always @(*) begin
    if (crc_valid) begin
      ack = 1;
      status = 8'hAC; // ACK status (e.g., 'AC' = Acknowledge)
    end else begin
      ack = 0;
      status = 8'hEE; // Error status (custom hex code for error)
    end
  end
endmodule


// ----------------------------
// Testbench
// ----------------------------
module can_tb;
  reg clk = 0;
  reg reset = 1;
  wire tick;
  wire [63:0] frame;
  wire [7:0] id;
  wire [3:0] dlc;
  wire [31:0] data;
  wire [6:0] crc;
  wire crc_valid;
  wire ack;
  wire [7:0] status;
  wire done;

  // Instantiate modules
  baud_gen bg(.clk(clk), .reset(reset), .tick(tick));
  can_frame_gen cfg(.clk(clk), .reset(reset), .tick(tick), .frame(frame), .done(done));
  can_frame_rx rx(.frame(frame), .id(id), .dlc(dlc), .data(data), .crc(crc));
  can_crc_checker crc_chk(.raw_data(frame[63:16]), .received_crc(crc), .crc_valid(crc_valid));
  ack_checker ackc(.crc_valid(crc_valid), .ack(ack), .status(status));

  always #5 clk = ~clk; // 100MHz clock

  initial begin
    $dumpfile("dump.vcd"); 
    $dumpvars;

    $display("----- CAN Protocol Project Started -----");
    reset = 1; #20; reset = 0;

    wait(done);
    $display("ID    = %b", id);
    $display("DLC   = %b", dlc);
    $display("DATA  = %h", data);
    $display("CRC   = %b", crc);
    #10;
    if (crc_valid)
      $display("✔ CRC MATCHED. Integrity OK!");
    else
      $display("✘ CRC MISMATCH. Frame Corrupted!");

    $display("ACK   = %b | STATUS = %h", ack, status);
    $display("----- Test Ended -----");
    #10 $finish;
  end
endmodule
